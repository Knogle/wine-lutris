From 308c42c712eee011da4b1e53c3172c1ca226eed3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 21 May 2021 14:57:46 +0200
Subject: [PATCH] user32: Implement rudimentary EnableMouseInPointer support.

CW-Bug-Id: 18943
---
 dlls/user32/input.c        |  9 +++++----
 dlls/user32/message.c      | 32 ++++++++++++++++++++++++++++++++
 dlls/user32/user_private.h |  1 +
 include/winuser.h          | 26 ++++++++++++++++++++++++++
 4 files changed, 64 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index a3b5916a01f..bbc3d8cba63 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -1144,15 +1144,16 @@ TrackMouseEvent (TRACKMOUSEEVENT *ptme)
     return TRUE;
 }

+BOOL enable_mouse_in_pointer = FALSE;
+
 /***********************************************************************
  *		EnableMouseInPointer (USER32.@)
  */
 BOOL WINAPI EnableMouseInPointer(BOOL enable)
 {
-    FIXME("(%#x) stub\n", enable);
-
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    FIXME("(%#x) semi-stub\n", enable);
+    enable_mouse_in_pointer = TRUE;
+    return TRUE;
 }

 static DWORD CALLBACK devnotify_window_callback(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 77902dd0c87..bd22a33b1f3 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2597,6 +2597,38 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
        in the WM_SETCURSOR message even if it's non-client mouse message */
     SendMessageW( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd, MAKELONG( hittest, msg->message ));

+    if (enable_mouse_in_pointer) switch (msg->message)
+    {
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_LBUTTONUP:
+    case WM_RBUTTONDOWN:
+    case WM_RBUTTONUP:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_XBUTTONDOWN:
+    case WM_XBUTTONUP:
+    {
+        WORD flags = POINTER_MESSAGE_FLAG_INRANGE|POINTER_MESSAGE_FLAG_INCONTACT|POINTER_MESSAGE_FLAG_PRIMARY;
+        if (msg->message == WM_LBUTTONDOWN) flags |= POINTER_MESSAGE_FLAG_FIRSTBUTTON;
+        if (msg->message == WM_RBUTTONDOWN) flags |= POINTER_MESSAGE_FLAG_SECONDBUTTON;
+        if (msg->message == WM_MBUTTONDOWN) flags |= POINTER_MESSAGE_FLAG_THIRDBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_LBUTTON) flags |= POINTER_MESSAGE_FLAG_FIRSTBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_RBUTTON) flags |= POINTER_MESSAGE_FLAG_SECONDBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_MBUTTON) flags |= POINTER_MESSAGE_FLAG_THIRDBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_XBUTTON1) flags |= POINTER_MESSAGE_FLAG_FOURTHBUTTON;
+        if (msg->message == WM_XBUTTONDOWN && LOWORD( msg->wParam ) == MK_XBUTTON2) flags |= POINTER_MESSAGE_FLAG_FIFTHBUTTON;
+        SendMessageW( msg->hwnd, WM_POINTERUPDATE, MAKELONG( 1, flags ), MAKELONG( msg->pt.x, msg->pt.y ) );
+        break;
+    }
+    case WM_MOUSEWHEEL:
+        SendMessageW( msg->hwnd, WM_POINTERWHEEL, MAKELONG( 1, HIWORD( msg->wParam ) ), MAKELONG( msg->pt.x, msg->pt.y ) );
+        break;
+    case WM_MOUSEHWHEEL:
+        SendMessageW( msg->hwnd, WM_POINTERHWHEEL, MAKELONG( 1, HIWORD( msg->wParam ) ), MAKELONG( msg->pt.x, msg->pt.y ) );
+        break;
+    }
+
     msg->message = message;
     return !eatMsg;
 }
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 6923ddb2906..63e14c20a3d 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -152,6 +152,7 @@ static inline BOOL is_broadcast( HWND hwnd )
 }

 extern HMODULE user32_module DECLSPEC_HIDDEN;
+extern BOOL enable_mouse_in_pointer DECLSPEC_HIDDEN;

 struct dce;
 struct tagWND;
diff --git a/include/winuser.h b/include/winuser.h
index 1d37bd44344..198c3ded77f 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -3475,6 +3475,32 @@ typedef struct tagMENUGETOBJECTINFO
     void  *pvObj;
 } MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;

+#define POINTER_MESSAGE_FLAG_NEW                      0x00000001
+#define POINTER_MESSAGE_FLAG_INRANGE                  0x00000002
+#define POINTER_MESSAGE_FLAG_INCONTACT                0x00000004
+#define POINTER_MESSAGE_FLAG_FIRSTBUTTON              0x00000010
+#define POINTER_MESSAGE_FLAG_SECONDBUTTON             0x00000020
+#define POINTER_MESSAGE_FLAG_THIRDBUTTON              0x00000040
+#define POINTER_MESSAGE_FLAG_FOURTHBUTTON             0x00000080
+#define POINTER_MESSAGE_FLAG_FIFTHBUTTON              0x00000100
+#define POINTER_MESSAGE_FLAG_PRIMARY                  0x00002000
+#define POINTER_MESSAGE_FLAG_CONFIDENCE               0x00004000
+#define POINTER_MESSAGE_FLAG_CANCELED                 0x00008000
+
+#define GET_POINTERID_WPARAM(wparam)                  (LOWORD(wparam))
+#define IS_POINTER_FLAG_SET_WPARAM(wparam, flags)     ((HIWORD(wparam) & (flags)) == (flags))
+#define IS_POINTER_NEW_WPARAM(wparam)                 IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_NEW)
+#define IS_POINTER_INRANGE_WPARAM(wparam)             IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_INRANGE)
+#define IS_POINTER_INCONTACT_WPARAM(wparam)           IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_INCONTACT)
+#define IS_POINTER_FIRSTBUTTON_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_FIRSTBUTTON)
+#define IS_POINTER_SECONDBUTTON_WPARAM(wparam)        IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_SECONDBUTTON)
+#define IS_POINTER_THIRDBUTTON_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_THIRDBUTTON)
+#define IS_POINTER_FOURTHBUTTON_WPARAM(wparam)        IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_FOURTHBUTTON)
+#define IS_POINTER_FIFTHBUTTON_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_FIFTHBUTTON)
+#define IS_POINTER_PRIMARY_WPARAM(wparam)             IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_PRIMARY)
+#define HAS_POINTER_CONFIDENCE_WPARAM(wparam)         IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_CONFIDENCE)
+#define IS_POINTER_CANCELED_WPARAM(wparam)            IS_POINTER_FLAG_SET_WPARAM(wparam, POINTER_MESSAGE_FLAG_CANCELED)
+
 #if defined(_WINGDI_) && !defined(NOGDI)
 WINUSERAPI LONG        WINAPI ChangeDisplaySettingsA(LPDEVMODEA,DWORD);
 WINUSERAPI LONG        WINAPI ChangeDisplaySettingsW(LPDEVMODEW,DWORD);
From f0b709b13fbb5f269f929cfe67b62b8704d1e800 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 15:07:28 -0500
Subject: [PATCH] HACK: user32: Remove hooks that time out.

In accordance with Win7+ behaviour.
---
 dlls/user32/hook.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/dlls/user32/hook.c b/dlls/user32/hook.c
index 159797020f2..e8a31100646 100644
--- a/dlls/user32/hook.c
+++ b/dlls/user32/hook.c
@@ -387,6 +387,7 @@ void *get_hook_proc( void *proc, const WCHAR *module, HMODULE *free_module )
 static LRESULT call_hook( struct hook_info *info, INT code, WPARAM wparam, LPARAM lparam )
 {
     DWORD_PTR ret = 0;
+    LRESULT lres = 0;
 
     if (info->tid)
     {
@@ -400,20 +401,24 @@ static LRESULT call_hook( struct hook_info *info, INT code, WPARAM wparam, LPARA
         switch(info->id)
         {
         case WH_KEYBOARD_LL:
-            MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
-                                            wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                            get_ll_hook_timeout(), &ret );
+            lres = MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
+                wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG, get_ll_hook_timeout(), &ret );
             break;
         case WH_MOUSE_LL:
-            MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
-                                            wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                            get_ll_hook_timeout(), &ret );
+            lres = MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
+                wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG, get_ll_hook_timeout(), &ret );
             break;
         default:
             ERR("Unknown hook id %d\n", info->id);
             assert(0);
             break;
         }
+
+        if (!lres && GetLastError() == ERROR_TIMEOUT)
+        {
+            TRACE("Hook %p timed out; removing it.\n", info->handle);
+            UnhookWindowsHookEx( info->handle );
+        }
     }
     else if (info->proc)
     {
From 67274cfa92b7ace6693b14f4911dcf9b4084fae3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 15:10:08 -0500
Subject: [PATCH] HACK: server: Don't check for a hung queue when sending
 low-level hooks.

Since user32 does this.

This logic is independent of the SMTO_ABORTIFHUNG logic on Windows. In fact, IsHungAppWindow() uses yet another algorithm.
---
 server/queue.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/server/queue.c b/server/queue.c
index 77ee67066e0..dea4b835ab2 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1661,7 +1661,6 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa

     if (!(hook_thread = get_first_global_hook( id ))) return 0;
     if (!(queue = hook_thread->queue)) return 0;
-    if (is_queue_hung( queue )) return 0;

     if (!(msg = mem_alloc( sizeof(*msg) ))) return 0;

